Итоговый отчет по НТО от команды `pwn is 0x12c bucks`
==========

## crypto1
Решалка: [script.sage](crypto1/script.sage)

Дан какой-то шифровальщик, который шифрует каждый байт независимо и детерминированно. Вычислим значения для всех байтов (они различны для различных байтов), теперь мы умеем восстанавливать байт исходника по шифрованному байту (кинем все в dictionary или что-то подобное). Потом последовательно расшифруем каждый байт.

Флаг: `nto{5tr4ng3_gr0up_5tr4ng3_l0g_and_depressed_kid_zxc_ghoul}`



## crypto 2
Заметим, что в одном случае возвращается семь в большой степени по модулю, а в другом - случайное число в диапазоне от половины модуля до модуля. Сделаем предположение, что в первом случае вполне вероятно, что сервер вернет число, меньшее чем половина модуля. Запросим бит 10 раз, и если все 10 раз получилось число из диапазона `[n // 2; n]`, то скажем, что это 0, иначе 1. Скрипт для решения: [crypto20.py](crypto2/crypto20.py).

Флаг: `nto{0h_n0_t1m1ng}`

## pwn 2
Готовый эксплоит: [solve.py](pwn2/solve.py)

Исполняемый файл таков, что у нас есть доступ на запись к памяти размера `0x100` байт, при этом программа может совершить вызов функции `fclose` на с аргументом - указателем, состоящим из первых 8 байт этой области.

Создадим поддельную структуру `FILE *`, такую, что выполнив `fclose` на ней, мы получим шелл.

Для этого сначала вычислим адрес libc, воспользовавшись тем, что вывод данных производится при помощи `printf(data)`.

Далее создаем структуру с поддельной `vtable` таким образом, что на самом деле будет вызвана функция по нашему адресу. Находим подходящий адрес при помощи `one_gadget`.

И затем получаем флаг: `NTO{533_y0u_47_5ch00l_p4l}`

## pwn 3
Готовый эксплоит: [solve.py](pwn3/solve.py)

Как можно заметить, программа позволяет нам смотреть на участки памяти, которые уже были освобождены, а также редактировать их.

Для начала создаем несколько записей, потом удаляем их, тем самым заполняя tcache и unsorted bins. Смотря на содержимое одного из чанков, который попал в unsorted bins, мы можем получить адрес, куда была загружена libc.

Теперь переопределим `__free_hook` адресом (8 байт), прыгнув на который наша программа выдаст нам шелл. Для этого переопределим 4 байта по адресу `__free_hook`, а затем оставшиеся 4 байта по адресу `__free_hook+4`.

Переопределять 4 байта мы можем при помощи изменения структуры `tcache` таким образом, что адрес первого чанка будет указывать по адресу записи. Таким образом, при записи оценки (32-битного числа), мы запишем 4 байта в нужное место.

Осталось вызвать функцию `free` и получить флаг: `NTO{3ww_7h15_7c4ch3_15_p0150n3d}`

## rev 1
Открыв файл в дизассемблере, видим цикл с двумя инструкциями `int 0x21` и `int 0x15`.

![](rev1/r2.png)

`int 0x21` - это вызов DOS API, при этом `ah` устанавливается в `9` - записать строку в stdout.

`int 0x15` - вызов BIOS, при `ah` равным `0x86` - ожидание.

Заменив вызов `int 0x15` двумя байтами `0x90` (NOP), задержка исчезает и мы получаем флаг: `nto{h3ll0_n3w_5ch00l_fr0m_0ld!!}`

## web 1
Что происходит на сайте: при нажатии на кнопку calculate, он отправляет зашифрованные данные с клиента по сокету на сервер в формате `json`, затем сервер возвращает ответ. Если перехватить ответ сервера, видим, что он возвращает все данные, которые были получены, плюс что-то рассчитывает.

Замечание 1: данные отправляются на сервер в виде `{format: 'json', data: '<here_is_your_data>'}`. Поскольку явно указан формат данных, наверное можно отправить не json. Например, xml. Поскольку можно отправить xml, можно выполнить External Entity Injection: пейлоад будет выглядеть примерно так: `{"format": "xml", "data": "<!DOCTYPE foo [ <!ENTITY xxe SYSTEM \'file:///flag.txt\' >]><data><countries>&xxe;</countries><startdate></startdate><enddate></enddate><resttype></resttype></data>"}`

Флаг: `nto{w3bs0ck3ts_plu5_xx3_1s_l0v3}`

## web 2
Видно, что первый сервис формирует HTTP запрос ко второму самостоятельно, не экранируя при этом каким-либо образом параметр username. То есть, мы можем сформировать некорректный запрос, получив тем самым сообщение об ошибке, в котором будет содержаться флаг.

Пример запроса: 
```http
POST /register
username=%0A&password=qq
```


Флаг: `NTO{request_smuggling_917a34072663f9c8beea3b45e8f129c5}`

## web 3
Готовый эксплоит: [solve.py](web3/solve.py)

Нам предоставлена возможность совершать prototype pollution по адресу /pollute/key/value

Покопавшись в коде, понимаем, что можем передавать дополнительные параметры в функцию `passport.authenticate` (index.js строки 48-52)

```js
app.get("/auth", passport.authenticate('local', {
    successReturnToOrRedirect: '/',
    failureRedirect: '/error',
    failureMessage: true
}))
```

Посмотрев на список возможных параметров `AuthenticateOptions`, находим интересное поле `userProperty`, которое позволяет нам изменять объект `req`. Заменим это свойство на `isLocalRequest`, чтобы обмануть проверку в index.js:61. Однако этого мало, ведь при новом запросе создастся новый объект `req`, так что копнув глубже, мы можем обнаружить, что мы можем указать страницу, на которую мы хотим попасть после авторизации, для этого должно присутствовать поле `returnTo` у объекта `req.session` (authenticate.js:260-267)

```js
if (options.successReturnToOrRedirect) {
    var url = options.successReturnToOrRedirect;
    if (req.session && req.session.returnTo) {
        url = req.session.returnTo;
        delete req.session.returnTo;
    }
    return res.redirect(url);
}
```

Используя prototype pollution, устанавливаем значение этого поля в `'/admin/flag'` и получаем флаг: `nto{pr0t0typ3_pollut10n_g4dged5_f56acc00f5eb803de88496b}`
